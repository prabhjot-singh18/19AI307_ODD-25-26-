# Ex.No:3(C) ABSTRACTION
### QUESTION:
Design intelligent maze-exploring agents using **abstraction**.

A base abstract class `MazeAgent` declares:

```
abstract String generateNavigationCode(String[] maze);
```

Two agents extend it:

#### ScoutAgent  
- Detects special signals `@` in the maze.  
- Every time it sees `@`, it records the corridor **row number** (1-based).  
- Navigation code = sequence of row numbers where signals were found.

#### HunterAgent  
- Counts all obstructions `#` in the maze.  
- If obstructions ≥ 10 ⟶ output `"TRAPPED"`  
- Else ⟶ output `"ESCAPE"`

Input includes:
- number of maze rows  
- the maze rows  
- agent type (`1` = ScoutAgent, `2` = HunterAgent)

Output:
- Navigation code generated by the chosen agent.

---

### AIM:
To implement abstraction in Java by defining an abstract class and overriding its abstract method in derived classes that generate different navigation codes based on maze interpretation.

---

### ALGORITHM:

1. Define an abstract class `MazeAgent` with the abstract method `generateNavigationCode()`.  
2. Implement `ScoutAgent` that scans the maze and appends row numbers for every `@` found.  
3. Implement `HunterAgent` that counts `#` symbols and decides `"TRAPPED"` or `"ESCAPE"`.  
4. Read maze size and maze rows from the user.  
5. Based on input type (1 or 2), create the correct agent object.  
6. Call `generateNavigationCode()` and print the result.

---

### PROGRAM:

```
Program to demonstrate abstraction using MazeAgent, ScoutAgent, and HunterAgent
Developed by: PRABHJOT SINGH
RegisterNumber: 212222040116
```

---

### Sourcecode.java:

```java
import java.util.*;

abstract class MazeAgent {
    abstract String generateNavigationCode(String[] maze);
}

class ScoutAgent extends MazeAgent {
    @Override
    String generateNavigationCode(String[] maze) {
        StringBuilder code = new StringBuilder();
        for (int i = 0; i < maze.length; i++) {
            for (char c : maze[i].toCharArray()) {
                if (c == '@') {
                    code.append(i + 1);
                }
            }
        }
        return code.toString();
    }
}

class HunterAgent extends MazeAgent {
    @Override
    String generateNavigationCode(String[] maze) {
        int count = 0;
        for (String row : maze) {
            for (char c : row.toCharArray()) {
                if (c == '#') count++;
            }
        }
        return (count >= 10) ? "TRAPPED" : "ESCAPE";
    }
}

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        int n = sc.nextInt();
        sc.nextLine();
        String[] maze = new String[n];

        for (int i = 0; i < n; i++) {
            maze[i] = sc.nextLine();
        }

        int type = sc.nextInt();

        MazeAgent agent = (type == 1) ? new ScoutAgent() : new HunterAgent();
        System.out.println(agent.generateNavigationCode(maze));

        sc.close();
    }
}
```

---

### OUTPUT:
<img width="478" height="206" alt="image" src="https://github.com/user-attachments/assets/3285d7d1-45f1-4e16-8548-5e0520a4b7df" />


---

### RESULT:
Thus, the Java program implementing abstraction using MazeAgent, ScoutAgent, and HunterAgent was successfully executed.



